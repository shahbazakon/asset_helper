import 'dart:io';

import 'package:path/path.dart' as path;

import 'config.dart';
import 'models/asset_file.dart';
import 'utils/file_utils.dart';

/// Main class for generating asset references
class AssetGenerator {
  /// Project root directory
  final String projectRoot;

  /// Configuration for the generator
  final Config config;

  /// Constructor
  AssetGenerator({
    required this.projectRoot,
    Config? config,
  }) : config = config ?? Config.fromPubspec(projectRoot);

  /// Generate asset reference file
  Future<String> generateAssets() async {
    final assetFiles = _scanAssets();
    final outputFile = _generateReferenceFile(assetFiles);
    return outputFile;
  }

  /// Scan for assets in configured directories
  List<AssetFile> _scanAssets() {
    final allAssets = <AssetFile>[];

    // First, check assets declared in pubspec.yaml
    // final declaredAssets = FileUtils.getAssetsFromPubspec(projectRoot);

    // Scan each asset directory
    for (final assetDir in config.assetDirs) {
      final dirPath = path.join(projectRoot, assetDir);
      if (!Directory(dirPath).existsSync()) {
        continue;
      }

      final assets = FileUtils.scanAssetDirectory(dirPath, baseDir: projectRoot);

      // Filter assets based on extension if needed
      final filteredAssets = assets.where((asset) {
        // If include extensions is provided, only include those
        if (config.includeExtensions.isNotEmpty) {
          return config.includeExtensions.contains(asset.extension);
        }

        // Otherwise, exclude specified extensions
        if (config.excludeExtensions.isNotEmpty) {
          return !config.excludeExtensions.contains(asset.extension);
        }

        return true;
      }).toList();

      allAssets.addAll(filteredAssets);
    }

    return allAssets;
  }

  /// Generate the reference file from asset files
  String _generateReferenceFile(List<AssetFile> assetFiles) {
    // Group assets by their directory structure
    final assetGroups = <String, List<AssetFile>>{};

    for (final asset in assetFiles) {
      final dir = path.dirname(asset.relativePath);
      assetGroups.putIfAbsent(dir, () => []).add(asset);
    }

    // Generate the file content
    final buffer = StringBuffer();

    // Add file header
    buffer.writeln('// Generated file. Do not edit.');
    buffer.writeln('// Generated by auto_asset_gen package');
    buffer.writeln();

    // Add the main class
    if (config.useNewNamingConvention) {
      // New format: Class with final String fields
      buffer.writeln('class ${config.assetClassName} {');
      _generateFlatReferences(buffer, assetFiles, 2);
      buffer.writeln('}');
    } else {
      // Original format: Nested static const strings
      buffer.writeln('class ${config.assetClassName} {');
      buffer.writeln('  ${config.assetClassName}._();');
      buffer.writeln();

      // Generate nested classes and asset paths
      _generateNestedClasses(buffer, assetGroups, '', 2);

      buffer.writeln('}');
    }

    // Write the file
    final outputPath = path.join(projectRoot, config.outputDir, 'assets.dart');
    FileUtils.writeToFile(outputPath, buffer.toString());

    return outputPath;
  }

  /// Generate flat references in the format: final String IconsHomeSVG = "assets/icons/home.svg";
  void _generateFlatReferences(StringBuffer buffer, List<AssetFile> assetFiles, int indentLevel) {
    final indent = ' ' * indentLevel;

    // Sort assets alphabetically for better readability
    assetFiles.sort((a, b) => a.relativePath.compareTo(b.relativePath));

    for (final asset in assetFiles) {
      final varName = _sanitizeVariableName(asset.newVariableName);
      buffer.writeln('${indent}final String $varName = \'${asset.relativePath}\';');
    }
  }

  /// Generate nested classes for directory structure
  void _generateNestedClasses(StringBuffer buffer, Map<String, List<AssetFile>> assetGroups,
      String currentPath, int indentLevel) {
    final indent = ' ' * indentLevel;

    // Get direct assets in this path
    final assets = assetGroups[currentPath] ?? [];

    // Add assets as static constants
    for (final asset in assets) {
      if (config.includeComments) {
        buffer.writeln('${indent}/// Asset file: ${asset.relativePath}');
      }

      final varName = config.useNewNamingConvention
          ? _sanitizeVariableName(asset.newVariableName)
          : _sanitizeVariableName(asset.variableName);

      buffer.writeln('${indent}static const String $varName = \'${asset.relativePath}\';');
    }

    if (assets.isNotEmpty) {
      buffer.writeln();
    }

    // Find subfolders
    final subfolders = <String>{};
    for (final dir in assetGroups.keys) {
      if (dir == currentPath || !dir.startsWith(currentPath)) continue;

      final subPath = dir.substring(currentPath.isEmpty ? 0 : currentPath.length + 1);
      final firstSegment = subPath.split('/').first;

      if (firstSegment.isNotEmpty) {
        subfolders.add(firstSegment);
      }
    }

    // Generate child classes for each subfolder
    for (final subfolder in subfolders) {
      final className = _toClassName(subfolder);
      // final newPath =
      //     currentPath.isEmpty ? subfolder : '$currentPath/$subfolder';

      if (config.includeComments) {
        buffer.writeln('${indent}/// ${className} assets');
      }

      buffer.writeln('${indent}static const $className $subfolder = $className._();');
    }

    // Generate the nested classes
    for (final subfolder in subfolders) {
      buffer.writeln();
      final className = _toClassName(subfolder);
      final newPath = currentPath.isEmpty ? subfolder : '$currentPath/$subfolder';

      buffer.writeln('${indent}class $className {');
      buffer.writeln('${indent}  const $className._();');
      buffer.writeln();

      _generateNestedClasses(buffer, assetGroups, newPath, indentLevel + 2);

      buffer.writeln('${indent}}');
    }
  }

  /// Convert a folder name to a valid class name
  String _toClassName(String name) {
    // Replace non-alphanumeric with underscores
    var className = name.replaceAll(RegExp(r'[^\w]'), '_');

    // Capitalize first letter
    if (className.isNotEmpty) {
      className = className[0].toUpperCase() + className.substring(1);
    }

    return className;
  }

  /// Sanitize variable name to be valid Dart identifier
  String _sanitizeVariableName(String name) {
    // Replace invalid characters
    var varName = name.replaceAll(RegExp(r'[^\w]'), '_');

    // Ensure it starts with a letter or underscore, not a number
    if (varName.isNotEmpty && RegExp(r'^\d').hasMatch(varName)) {
      varName = '_$varName';
    }

    return varName;
  }
}
