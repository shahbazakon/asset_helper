import 'dart:io';

import 'package:path/path.dart' as path;

import 'config.dart';
import 'models/asset_file.dart';
import 'utils/file_utils.dart';

/// Main class for generating asset references
class AssetGenerator {
  /// Project root directory
  final String projectRoot;

  /// Configuration for the generator
  final Config config;

  /// Constructor
  AssetGenerator({
    required this.projectRoot,
    Config? config,
  }) : config = config ?? Config.fromPubspec(projectRoot);

  /// Generate asset reference file
  Future<String> generateAssets() async {
    final assetFiles = _scanAssets();
    final outputFile = _generateReferenceFile(assetFiles);
    return outputFile;
  }

  /// Scan for assets in configured directories
  List<AssetFile> _scanAssets() {
    final allAssets = <AssetFile>[];

    // Scan each asset directory
    for (final assetDir in config.assetDirs) {
      final dirPath = path.join(projectRoot, assetDir);
      if (!Directory(dirPath).existsSync()) {
        continue;
      }

      final assets = FileUtils.scanAssetDirectory(dirPath, baseDir: projectRoot);

      // Filter assets based on extension if needed
      final filteredAssets = assets.where((asset) {
        // If include extensions is provided, only include those
        if (config.includeExtensions.isNotEmpty) {
          return config.includeExtensions.contains(asset.extension);
        }

        // Otherwise, exclude specified extensions
        if (config.excludeExtensions.isNotEmpty) {
          return !config.excludeExtensions.contains(asset.extension);
        }

        return true;
      }).toList();

      allAssets.addAll(filteredAssets);
    }

    return allAssets;
  }

  /// Generate the reference file from asset files
  String _generateReferenceFile(List<AssetFile> assetFiles) {
    // Group assets by their directory structure
    final assetGroups = <String, List<AssetFile>>{};

    for (final asset in assetFiles) {
      final dir = path.dirname(asset.relativePath);
      assetGroups.putIfAbsent(dir, () => []).add(asset);
    }

    // Generate the file content
    final buffer = StringBuffer();

    // Add file header
    buffer.writeln('// Generated file. Do not edit.');
    buffer.writeln('// Generated by auto_asset_gen package');
    buffer.writeln();

    // Add the main class
    if (config.useNewNamingConvention) {
      // New format: Class with final String fields
      buffer.writeln('class ${config.assetClassName} {');
      _generateFlatReferences(buffer, assetFiles, 2);
      buffer.writeln('}');
    } else {
      // Original format: Nested static const strings
      buffer.writeln('class ${config.assetClassName} {');
      buffer.writeln('  ${config.assetClassName}._();');
      buffer.writeln();

      // Generate nested classes and asset paths
      _generateNestedClasses(buffer, assetGroups, '', 2);

      buffer.writeln('}');
    }

    // Write the file
    final outputPath = path.join(projectRoot, config.outputDir, 'assets.dart');
    FileUtils.writeToFile(outputPath, buffer.toString());

    return outputPath;
  }

  /// Generate flat references in the format: final String IconsHomeSVG = "assets/icons/home.svg";
  void _generateFlatReferences(StringBuffer buffer, List<AssetFile> assetFiles, int indentLevel) {
    final indent = ' ' * indentLevel;

    // Sort assets alphabetically for better readability
    assetFiles.sort((a, b) => a.relativePath.compareTo(b.relativePath));

    for (final asset in assetFiles) {
      // Get just the current folder name and the file name for the variable
      final pathParts = path.split(asset.relativePath);
      String currentFolder = '';

      // Get the parent folder name if it exists
      if (pathParts.length >= 2) {
        currentFolder = pathParts[pathParts.length - 2];
        // Properly capitalize first letter of folder for camelCase
        if (currentFolder.isNotEmpty) {
          currentFolder = _toCamelCase(currentFolder);
        }
      }

      // Get filename without extension
      final fileName = path.basenameWithoutExtension(asset.relativePath);
      // Convert filename to proper camelCase (handling underscores and hyphens)
      final capitalizedFileName = _toCamelCase(fileName);

      // Get uppercase extension without the dot
      final ext = asset.extension.toUpperCase().replaceAll('.', '');

      // Create variable name with folder + file + extension
      final varName = _sanitizeVariableName('$currentFolder$capitalizedFileName$ext');

      buffer.writeln('${indent}final String $varName = \'${asset.relativePath}\';');
    }
  }

  /// Generate nested classes for directory structure
  void _generateNestedClasses(StringBuffer buffer, Map<String, List<AssetFile>> assetGroups,
      String currentPath, int indentLevel) {
    final indent = ' ' * indentLevel;

    // Get direct assets in this path
    final assets = assetGroups[currentPath] ?? [];

    // Add assets as static constants
    for (final asset in assets) {
      // Use just the filename for the variable name, not the full path
      final fileName = path.basenameWithoutExtension(asset.relativePath);
      final capitalizedFileName = _toCamelCase(fileName);

      final varName = _sanitizeVariableName(
          capitalizedFileName + asset.extension.toUpperCase().replaceAll('.', ''));

      buffer.writeln('${indent}static const String $varName = \'${asset.relativePath}\';');
    }

    if (assets.isNotEmpty) {
      buffer.writeln();
    }

    // Find subfolders
    final subfolders = <String>{};
    for (final dir in assetGroups.keys) {
      if (dir == currentPath || !dir.startsWith(currentPath)) continue;

      final subPath = dir.substring(currentPath.isEmpty ? 0 : currentPath.length + 1);
      final firstSegment = subPath.split('/').first;

      if (firstSegment.isNotEmpty) {
        subfolders.add(firstSegment);
      }
    }

    // Generate child classes for each subfolder
    for (final subfolder in subfolders) {
      final className = _toClassName(subfolder);

      if (config.includeComments) {
        buffer.writeln('${indent}/// ${className} assets');
      }

      buffer.writeln('${indent}static const $className $subfolder = $className._();');
    }

    // Generate the nested classes
    for (final subfolder in subfolders) {
      buffer.writeln();
      final className = _toClassName(subfolder);
      final newPath = currentPath.isEmpty ? subfolder : '$currentPath/$subfolder';

      buffer.writeln('${indent}class $className {');
      buffer.writeln('${indent}  const $className._();');
      buffer.writeln();

      _generateNestedClasses(buffer, assetGroups, newPath, indentLevel + 2);

      buffer.writeln('${indent}}');
    }
  }

  /// Convert a folder name to a valid class name
  String _toClassName(String name) {
    // Replace non-alphanumeric with underscores
    var className = name.replaceAll(RegExp(r'[^\w]'), '_');

    // Capitalize first letter
    if (className.isNotEmpty) {
      className = className[0].toUpperCase() + className.substring(1);
    }

    return className;
  }

  /// Sanitize variable name to be valid Dart identifier
  String _sanitizeVariableName(String name) {
    // Replace invalid characters
    var varName = name.replaceAll(RegExp(r'[^\w]'), '_');

    // Ensure it starts with a letter or underscore, not a number
    if (varName.isNotEmpty && RegExp(r'^\d').hasMatch(varName)) {
      varName = '_$varName';
    }

    return varName;
  }

  /// Convert string to proper camelCase
  String _toCamelCase(String text) {
    if (text.isEmpty) {
      return text;
    }

    // First replace any hyphens with underscores for consistent handling
    text = text.replaceAll('-', '_');

    // Split by underscore and capitalize each segment
    final segments = text.split('_');
    final result = StringBuffer();

    // Add each segment with first letter capitalized
    for (var segment in segments) {
      if (segment.isEmpty) continue;
      result.write(segment[0].toUpperCase() + segment.substring(1));
    }

    return result.toString();
  }
}
